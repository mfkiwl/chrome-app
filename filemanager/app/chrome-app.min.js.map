{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///chrome-app.min.js","webpack:///webpack/bootstrap 03a4fa98620d86cef2b0","webpack:///./src/chrome-app/index.js","webpack:///./~/debug/browser.js","webpack:///./~/debug/debug.js","webpack:///./~/debug/~/ms/index.js","webpack:///./src/chrome-app/MessageHandler.js","webpack:///./src/chrome-app/api/fileSystem.js","webpack:///./src/chrome-app/storage.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Debug","enable","MessageHandler","initConnection","element","document","getElementById","Error","handler","register","useColors","documentElement","style","window","console","firebug","exception","table","navigator","userAgent","toLowerCase","match","parseInt","RegExp","$1","formatArgs","args","arguments","namespace","humanize","diff","color","concat","Array","prototype","slice","index","lastC","replace","splice","log","Function","apply","save","namespaces","storage","removeItem","debug","e","load","r","localstorage","localStorage","chrome","local","colors","formatters","j","v","JSON","stringify","selectColor","prevColor","length","disabled","enabled","self","curr","Date","ms","prevTime","prev","coerce","format","formatter","val","logFn","bind","fn","split","len","i","skips","push","substr","names","disable","name","test","stack","message","parse","str","exec","n","parseFloat","type","y","d","h","s","short","Math","round","long","plural","floor","ceil","options","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","messageHandlers","Map","addEventListener","event","data","windowID","has","get","handleMessage","theWindow","registeredHandlers","set","contentWindow","postMessage","value","types","shift","status","setTimeout","callback","_defineProperty","obj","selectDirectory","label","chooseEntry","then","entry","entryID","fileSystem","retainEntry","saveEntry","readDirectory","getEntry","directory","Promise","resolve","reject","readEntries","reader","theEntries","entries","map","isFile","isDirectory","createReader","readFile","_ref","undefined","_ref$encoding","encoding","getFile","create","fileEntry","file","FileReader","onload","result","onerror","error","readAsText","readAsDataURL","readAsArrayBuffer","readAsBinaryString","writeFile","_ref2","_ref2$encoding","_ref2$exclusive","exclusive","_ref2$type","createWriter","fileWriter","onwriteend","write","getBlob","truncate","Blob","parts","contentType","raw","atob","uInt8Array","Uint8Array","charCodeAt","Storage","STORAGE_FS","restoreEntry","runtime","lastError","prom","res","err","store","items","remove","clear"],"mappings":"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","file":"chrome-app.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ChromeAppManager\"] = factory();\n\telse\n\t\troot[\"ChromeAppManager\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ChromeAppManager\"] = factory();\n\telse\n\t\troot[\"ChromeAppManager\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Debug = __webpack_require__(1);\n\tDebug.enable('*');\n\t\n\tvar MessageHandler = __webpack_require__(4);\n\t\n\texports.initConnection = function initConnection(id) {\n\t    var element = document.getElementById(id);\n\t    if (!element) throw new Error('Element #' + id + ' not found in the DOM');\n\t    var handler = new MessageHandler(element);\n\t\n\t    // register here the handlers from ./api\n\t    handler.register('fileSystem', __webpack_require__(5));\n\t\n\t    return handler;\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(2);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  return ('WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  return JSON.stringify(v);\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs() {\n\t  var args = arguments;\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return args;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t  return args;\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    r = exports.storage.debug;\n\t  } catch(e) {}\n\t  return r;\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage(){\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = debug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(3);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lowercased letter, i.e. \"n\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previously assigned color.\n\t */\n\t\n\tvar prevColor = 0;\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t *\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor() {\n\t  return exports.colors[prevColor++ % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction debug(namespace) {\n\t\n\t  // define the `disabled` version\n\t  function disabled() {\n\t  }\n\t  disabled.enabled = false;\n\t\n\t  // define the `enabled` version\n\t  function enabled() {\n\t\n\t    var self = enabled;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // add the `color` if not set\n\t    if (null == self.useColors) self.useColors = exports.useColors();\n\t    if (null == self.color && self.useColors) self.color = selectColor();\n\t\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %o\n\t      args = ['%o'].concat(args);\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    if ('function' === typeof exports.formatArgs) {\n\t      args = exports.formatArgs.apply(self, args);\n\t    }\n\t    var logFn = enabled.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t  enabled.enabled = true;\n\t\n\t  var fn = exports.enabled(namespace) ? enabled : disabled;\n\t\n\t  fn.namespace = namespace;\n\t\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000;\n\tvar m = s * 60;\n\tvar h = m * 60;\n\tvar d = h * 24;\n\tvar y = d * 365.25;\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(val, options){\n\t  options = options || {};\n\t  if ('string' == typeof val) return parse(val);\n\t  return options.long\n\t    ? long(val)\n\t    : short(val);\n\t};\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = '' + str;\n\t  if (str.length > 10000) return;\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\t  if (!match) return;\n\t  var n = parseFloat(match[1]);\n\t  var type = (match[2] || 'ms').toLowerCase();\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y;\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d;\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h;\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m;\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s;\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n;\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction short(ms) {\n\t  if (ms >= d) return Math.round(ms / d) + 'd';\n\t  if (ms >= h) return Math.round(ms / h) + 'h';\n\t  if (ms >= m) return Math.round(ms / m) + 'm';\n\t  if (ms >= s) return Math.round(ms / s) + 's';\n\t  return ms + 'ms';\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction long(ms) {\n\t  return plural(ms, d, 'day')\n\t    || plural(ms, h, 'hour')\n\t    || plural(ms, m, 'minute')\n\t    || plural(ms, s, 'second')\n\t    || ms + ' ms';\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) return;\n\t  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n\t  return Math.ceil(ms / n) + ' ' + name + 's';\n\t}\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar debug = __webpack_require__(1)('chrome-app');\n\t\n\tvar messageHandlers = new Map();\n\t\n\tvar id = 0;\n\t\n\twindow.addEventListener('message', function (event) {\n\t    var data = event.data;\n\t    if (!data.windowID) {\n\t        return debug('received a message without windowID', data);\n\t    }\n\t    if (!data.type) {\n\t        return debug('received a message without type', data);\n\t    }\n\t    if (!messageHandlers.has(data.windowID)) {\n\t        return debug('window with id ' + data.windowID + ' not found', data);\n\t    }\n\t    messageHandlers.get(data.windowID).handleMessage(data);\n\t});\n\t\n\tvar MessageHandler = (function () {\n\t    function MessageHandler(theWindow) {\n\t        _classCallCheck(this, MessageHandler);\n\t\n\t        debug('creating message handler');\n\t        this.window = null;\n\t        this.windowID = ++id;\n\t        this.registeredHandlers = new Map();\n\t        messageHandlers.set(this.windowID, this);\n\t        var self = this;\n\t        theWindow.addEventListener('contentload', function () {\n\t            debug('establish connection');\n\t            self.window = theWindow.contentWindow;\n\t            self.postMessage({ type: 'admin.connect', message: self.windowID });\n\t        });\n\t    }\n\t\n\t    _createClass(MessageHandler, [{\n\t        key: 'postMessage',\n\t        value: function postMessage(message) {\n\t            debug('post message', message);\n\t            this.window.postMessage(message, '*');\n\t        }\n\t    }, {\n\t        key: 'handleMessage',\n\t        value: function handleMessage(data) {\n\t            debug('receive message', data);\n\t            var types = data.type.split('.');\n\t            var type = types.shift();\n\t            switch (type) {\n\t                case 'admin':\n\t                    if (types[0] === 'connect') {}\n\t                    break;\n\t                case 'test':\n\t                    data.status = 'warn';\n\t                    this.postMessage(data);\n\t                    data.message *= 100;\n\t                    this.postMessage(data);\n\t                    var self = this;\n\t                    setTimeout(function () {\n\t                        data.status = 'success';\n\t                        data.message = 'hello';\n\t                        self.postMessage(data);\n\t                    }, 300);\n\t                    break;\n\t                default:\n\t                    if (this.registeredHandlers.has(type)) {\n\t                        this.registeredHandlers.get(type).call(this, data, types);\n\t                    } else {\n\t                        var message = 'no handler registered for type ' + type;\n\t                        debug(message);\n\t                        data.status = 'error';\n\t                        data.message = message;\n\t                        this.postMessage(data);\n\t                    }\n\t                    break;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'register',\n\t        value: function register(type, callback) {\n\t            this.registeredHandlers.set(type, callback);\n\t        }\n\t    }]);\n\t\n\t    return MessageHandler;\n\t})();\n\t\n\tmodule.exports = MessageHandler;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar debug = __webpack_require__(1)('fileSystem');\n\tvar Storage = __webpack_require__(6);\n\t\n\tvar STORAGE_FS = 'fileSystem.directories';\n\t\n\tmodule.exports = function (data, types) {\n\t    debug('fs call');\n\t\n\t    var message = data.message;\n\t    if (!message || typeof message.label !== 'string') {\n\t        data.status = 'error';\n\t        data.message = 'fileSystem actions need a label';\n\t        return this.postMessage(data);\n\t    }\n\t\n\t    var prom = undefined;\n\t    switch (types[0]) {\n\t        case 'selectDirectory':\n\t            prom = selectDirectory(message.label);\n\t            break;\n\t        case 'readDirectory':\n\t            prom = readDirectory(message.label);\n\t            break;\n\t        case 'readFile':\n\t            prom = readFile(message.label, message.name, message.options);\n\t            break;\n\t        case 'writeFile':\n\t            prom = writeFile(message.label, message.name, message.data, message.options);\n\t            break;\n\t        default:\n\t            prom = Promise.reject('Unknown fileSystem action: ' + types[0]);\n\t            break;\n\t    }\n\t\n\t    var self = this;\n\t    prom.then(function (res) {\n\t        data.status = 'success';\n\t        data.message = res;\n\t        self.postMessage(data);\n\t    }, function (err) {\n\t        data.status = 'error';\n\t        data.message = err;\n\t        self.postMessage(data);\n\t    });\n\t};\n\t\n\tfunction selectDirectory(label) {\n\t    debug('select directory: ' + label);\n\t    return chooseEntry({\n\t        type: 'openDirectory'\n\t    }).then(function (entry) {\n\t        var entryID = chrome.fileSystem.retainEntry(entry);\n\t        return saveEntry(label, entryID);\n\t    });\n\t}\n\t\n\tfunction readDirectory(label) {\n\t    debug('read directory: ' + label);\n\t    return getEntry(label).then(function (directory) {\n\t        return new Promise(function (resolve, reject) {\n\t            var reader = directory.createReader();\n\t            var entries = [];\n\t            readEntries();\n\t\n\t            function readEntries() {\n\t                reader.readEntries(function (theEntries) {\n\t                    if (theEntries.length === 0) {\n\t                        resolve(entries);\n\t                    } else {\n\t                        entries = entries.concat(theEntries.map(function (entry) {\n\t                            return {\n\t                                name: entry.name,\n\t                                isFile: entry.isFile,\n\t                                isDirectory: entry.isDirectory\n\t                            };\n\t                        }));\n\t                        readEntries();\n\t                    }\n\t                }, reject);\n\t            }\n\t        });\n\t    });\n\t}\n\t\n\tfunction readFile(label, name) {\n\t    var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t    var _ref$encoding = _ref.encoding;\n\t    var encoding = _ref$encoding === undefined ? 'text' : _ref$encoding;\n\t\n\t    debug('read file: ' + label + ' (' + name + ')');\n\t    return getEntry(label).then(function (directory) {\n\t        return new Promise(function (resolve, reject) {\n\t            directory.getFile(name, { create: false }, function (fileEntry) {\n\t                fileEntry.file(function (file) {\n\t                    var reader = new FileReader();\n\t                    reader.onload = function () {\n\t                        resolve(reader.result);\n\t                    };\n\t                    reader.onerror = function () {\n\t                        reject(reader.error);\n\t                    };\n\t                    if (encoding === 'text') {\n\t                        reader.readAsText(file);\n\t                    } else if (encoding === 'base64') {\n\t                        reader.readAsDataURL(file);\n\t                    } else if (encoding === 'buffer') {\n\t                        reader.readAsArrayBuffer(file);\n\t                    } else if (encoding === 'binary') {\n\t                        reader.readAsBinaryString(file);\n\t                    } else {\n\t                        reject('Unknown encoding: ' + encoding);\n\t                    }\n\t                }, reject);\n\t            }, reject);\n\t        });\n\t    });\n\t}\n\t\n\tfunction writeFile(label, name, data) {\n\t    var _ref2 = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t\n\t    var _ref2$encoding = _ref2.encoding;\n\t    var encoding = _ref2$encoding === undefined ? 'text' : _ref2$encoding;\n\t    var _ref2$exclusive = _ref2.exclusive;\n\t    var exclusive = _ref2$exclusive === undefined ? false : _ref2$exclusive;\n\t    var _ref2$type = _ref2.type;\n\t    var type = _ref2$type === undefined ? 'text/plain' : _ref2$type;\n\t\n\t    debug('write file: ' + label + ' (' + name + ')');\n\t    return getEntry(label).then(function (directory) {\n\t        return new Promise(function (resolve, reject) {\n\t            directory.getFile(name, { create: true, exclusive: exclusive }, function (fileEntry) {\n\t                fileEntry.createWriter(function (fileWriter) {\n\t                    fileWriter.onwriteend = function () {\n\t                        if (fileWriter.length === 0) {\n\t                            // file has been emptied, now we can write the new data\n\t                            fileWriter.write(getBlob(data, encoding, type));\n\t                        } else {\n\t                            resolve(true);\n\t                        }\n\t                    };\n\t                    fileWriter.onerror = reject;\n\t                    fileWriter.truncate(0); // empty the file\n\t                }, reject);\n\t            }, reject);\n\t        });\n\t    });\n\t}\n\t\n\tfunction getBlob(data, encoding, type) {\n\t    if (encoding === 'text') {\n\t        return new Blob([data], { type: type });\n\t    } else if (encoding === 'base64') {\n\t        var parts = data.split(';base64,');\n\t        var contentType = parts[0].split(':')[1];\n\t        var raw = atob(parts[1]);\n\t        var uInt8Array = new Uint8Array(raw.length);\n\t        for (var i = 0; i < raw.length; i++) {\n\t            uInt8Array[i] = raw.charCodeAt(i);\n\t        }\n\t        return new Blob([uInt8Array], { type: contentType });\n\t    } else if (encoding === 'buffer') {\n\t        var uInt8Array = new Uint8Array(data);\n\t        return new Blob([uInt8Array], { type: type });\n\t    }\n\t}\n\t\n\tfunction saveEntry(label, entryID) {\n\t    return Storage.get(STORAGE_FS).then(function (value) {\n\t        if (!value) {\n\t            value = _defineProperty({}, label, entryID);\n\t        } else {\n\t            value[label] = entryID;\n\t        }\n\t        return Storage.set(STORAGE_FS, value);\n\t    });\n\t}\n\t\n\tfunction getEntry(label) {\n\t    return Storage.get(STORAGE_FS).then(function (value) {\n\t        if (!value || !value[label]) {\n\t            return selectDirectory(label);\n\t        } else {\n\t            return value[label];\n\t        }\n\t    }).then(restoreEntry);\n\t}\n\t\n\t// promise wrappers for chrome.fileSystem API\n\tfunction chooseEntry(options) {\n\t    return new Promise(function (resolve, reject) {\n\t        chrome.fileSystem.chooseEntry(options, function (entry) {\n\t            if (chrome.runtime.lastError) {\n\t                reject(chrome.runtime.lastError);\n\t            } else {\n\t                resolve(entry);\n\t            }\n\t        });\n\t    });\n\t}\n\t\n\tfunction restoreEntry(id) {\n\t    return new Promise(function (resolve, reject) {\n\t        chrome.fileSystem.restoreEntry(id, function (entry) {\n\t            if (chrome.runtime.lastError) {\n\t                reject(chrome.runtime.lastError);\n\t            } else {\n\t                resolve(entry);\n\t            }\n\t        });\n\t    });\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar store = chrome.storage.local;\n\t\n\texports.get = function (key) {\n\t    return new Promise(function (resolve, reject) {\n\t        store.get(key, function (items) {\n\t            if (chrome.runtime.lastError) {\n\t                reject(chrome.runtime.lastError);\n\t            } else {\n\t                resolve(items[key]);\n\t            }\n\t        });\n\t    });\n\t};\n\t\n\texports.set = function (key, value) {\n\t    return new Promise(function (resolve, reject) {\n\t        store.set(_defineProperty({}, key, value), function () {\n\t            if (chrome.runtime.lastError) {\n\t                reject(chrome.runtime.lastError);\n\t            } else {\n\t                resolve(true);\n\t            }\n\t        });\n\t    });\n\t};\n\t\n\texports.remove = function (key) {\n\t    return new Promise(function (resolve, reject) {\n\t        store.remove(key, function () {\n\t            if (chrome.runtime.lastError) {\n\t                reject(chrome.runtime.lastError);\n\t            } else {\n\t                resolve(true);\n\t            }\n\t        });\n\t    });\n\t};\n\t\n\texports.clear = function () {\n\t    return new Promise(function (resolve, reject) {\n\t        store.clear(function () {\n\t            if (chrome.runtime.lastError) {\n\t                reject(chrome.runtime.lastError);\n\t            } else {\n\t                resolve(true);\n\t            }\n\t        });\n\t    });\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** chrome-app.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 03a4fa98620d86cef2b0\n **/","'use strict';\n\nconst Debug = require('debug');\nDebug.enable('*');\n\nconst MessageHandler = require('./MessageHandler');\n\nexports.initConnection = function initConnection(id) {\n    let element = document.getElementById(id);\n    if (!element) throw new Error(`Element #${id} not found in the DOM`);\n    let handler = new MessageHandler(element);\n\n    // register here the handlers from ./api\n    handler.register('fileSystem', require('./api/fileSystem'));\n\n    return handler;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/chrome-app/index.js\n **/","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/debug/browser.js\n ** module id = 1\n ** module chunks = 0\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/debug/debug.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/debug/~/ms/index.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nconst debug = require('debug')('chrome-app');\n\nconst messageHandlers = new Map();\n\nlet id = 0;\n\nwindow.addEventListener('message', function (event) {\n    let data = event.data;\n    if (!data.windowID) {\n        return debug('received a message without windowID', data);\n    }\n    if (!data.type) {\n        return debug('received a message without type', data);\n    }\n    if (!messageHandlers.has(data.windowID)) {\n        return debug(`window with id ${data.windowID} not found`, data);\n    }\n    messageHandlers.get(data.windowID).handleMessage(data);\n});\n\nclass MessageHandler {\n    constructor(theWindow) {\n        debug('creating message handler');\n        this.window = null;\n        this.windowID = ++id;\n        this.registeredHandlers = new Map();\n        messageHandlers.set(this.windowID, this);\n        let self = this;\n        theWindow.addEventListener('contentload', function () {\n            debug('establish connection');\n            self.window = theWindow.contentWindow;\n            self.postMessage({type: 'admin.connect', message: self.windowID});\n        });\n    }\n\n    postMessage(message) {\n        debug('post message', message);\n        this.window.postMessage(message, '*');\n    }\n\n    handleMessage(data) {\n        debug('receive message', data);\n        let types = data.type.split('.');\n        let type = types.shift();\n        switch (type) {\n            case 'admin':\n                if (types[0] === 'connect') {\n\n                }\n                break;\n            case 'test':\n                data.status = 'warn';\n                this.postMessage(data);\n                data.message *= 100;\n                this.postMessage(data);\n                let self = this;\n                setTimeout(function () {\n                    data.status = 'success';\n                    data.message = 'hello';\n                    self.postMessage(data);\n                }, 300);\n                break;\n            default:\n                if (this.registeredHandlers.has(type)) {\n                    this.registeredHandlers.get(type).call(this, data, types);\n                } else {\n                    let message = 'no handler registered for type ' + type;\n                    debug(message);\n                    data.status = 'error';\n                    data.message = message;\n                    this.postMessage(data);\n                }\n                break;\n        }\n    }\n\n    register(type, callback) {\n        this.registeredHandlers.set(type, callback);\n    }\n}\n\nmodule.exports = MessageHandler;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/chrome-app/MessageHandler.js\n **/","'use strict';\n\nconst debug = require('debug')('fileSystem');\nconst Storage = require('../storage');\n\nconst STORAGE_FS = 'fileSystem.directories';\n\nmodule.exports = function (data, types) {\n    debug('fs call');\n\n    let message = data.message;\n    if (!message || typeof message.label !== 'string') {\n        data.status = 'error';\n        data.message = 'fileSystem actions need a label';\n        return this.postMessage(data);\n    }\n\n    let prom;\n    switch (types[0]) {\n        case 'selectDirectory':\n            prom = selectDirectory(message.label);\n            break;\n        case 'readDirectory':\n            prom = readDirectory(message.label);\n            break;\n        case 'readFile':\n            prom = readFile(message.label, message.name, message.options);\n            break;\n        case 'writeFile':\n            prom = writeFile(message.label, message.name, message.data, message.options);\n            break;\n        default:\n            prom = Promise.reject('Unknown fileSystem action: ' + types[0]);\n            break;\n    }\n\n    const self = this;\n    prom.then(function (res) {\n        data.status = 'success';\n        data.message = res;\n        self.postMessage(data);\n    }, function (err) {\n        data.status = 'error';\n        data.message = err;\n        self.postMessage(data);\n    });\n};\n\nfunction selectDirectory(label) {\n    debug('select directory: ' + label);\n    return chooseEntry({\n        type: 'openDirectory'\n    }).then(function (entry) {\n        let entryID = chrome.fileSystem.retainEntry(entry);\n        return saveEntry(label, entryID);\n    });\n}\n\nfunction readDirectory(label) {\n    debug('read directory: ' + label);\n    return getEntry(label).then(function (directory) {\n        return new Promise(function (resolve, reject) {\n            let reader = directory.createReader();\n            let entries = [];\n            readEntries();\n\n            function readEntries() {\n                reader.readEntries(function (theEntries) {\n                    if (theEntries.length === 0) {\n                        resolve(entries);\n                    } else {\n                        entries = entries.concat(theEntries.map(function (entry) {\n                            return {\n                                name: entry.name,\n                                isFile: entry.isFile,\n                                isDirectory: entry.isDirectory\n                            };\n                        }));\n                        readEntries();\n                    }\n                }, reject);\n            }\n        });\n    });\n}\n\nfunction readFile(label, name, {encoding = 'text'} = {}) {\n    debug(`read file: ${label} (${name})`);\n    return getEntry(label).then(function (directory) {\n        return new Promise(function (resolve, reject) {\n            directory.getFile(name, {create: false}, function (fileEntry) {\n                fileEntry.file(function (file) {\n                    let reader = new FileReader();\n                    reader.onload = function () {\n                        resolve(reader.result);\n                    };\n                    reader.onerror = function () {\n                        reject(reader.error);\n                    };\n                    if (encoding === 'text') {\n                        reader.readAsText(file);\n                    } else if (encoding === 'base64') {\n                        reader.readAsDataURL(file);\n                    } else if (encoding === 'buffer') {\n                        reader.readAsArrayBuffer(file);\n                    } else if (encoding === 'binary') {\n                        reader.readAsBinaryString(file);\n                    } else {\n                        reject('Unknown encoding: ' + encoding);\n                    }\n                }, reject);\n            }, reject);\n        });\n    });\n}\n\nfunction writeFile(label, name, data, {\n    encoding = 'text',\n    exclusive = false,\n    type = 'text/plain'\n    } = {}) {\n    debug(`write file: ${label} (${name})`);\n    return getEntry(label).then(function (directory) {\n        return new Promise(function (resolve, reject) {\n            directory.getFile(name, {create: true, exclusive}, function (fileEntry) {\n                fileEntry.createWriter(function (fileWriter) {\n                    fileWriter.onwriteend = function () {\n                        if (fileWriter.length === 0) { // file has been emptied, now we can write the new data\n                            fileWriter.write(getBlob(data, encoding, type));\n                        } else {\n                            resolve(true);\n                        }\n                    };\n                    fileWriter.onerror = reject;\n                    fileWriter.truncate(0); // empty the file\n                }, reject);\n            }, reject);\n        });\n    });\n}\n\nfunction getBlob(data, encoding, type) {\n    if (encoding === 'text') {\n        return new Blob([data], {type});\n    } else if (encoding === 'base64') {\n        let parts = data.split(';base64,');\n        let contentType = parts[0].split(':')[1];\n        let raw = atob(parts[1]);\n        let uInt8Array = new Uint8Array(raw.length);\n        for (var i = 0; i < raw.length; i++) {\n            uInt8Array[i] = raw.charCodeAt(i);\n        }\n        return new Blob([uInt8Array], {type: contentType});\n    } else if (encoding === 'buffer') {\n        let uInt8Array = new Uint8Array(data);\n        return new Blob([uInt8Array], {type});\n    }\n}\n\nfunction saveEntry(label, entryID) {\n    return Storage.get(STORAGE_FS).then(function (value) {\n        if (!value) {\n            value = {\n                [label]: entryID\n            };\n        } else {\n            value[label] = entryID;\n        }\n        return Storage.set(STORAGE_FS, value);\n    });\n}\n\nfunction getEntry(label) {\n    return Storage.get(STORAGE_FS).then(function (value) {\n        if (!value || !value[label]) {\n            return selectDirectory(label);\n        } else {\n            return value[label];\n        }\n    }).then(restoreEntry);\n}\n\n// promise wrappers for chrome.fileSystem API\nfunction chooseEntry(options) {\n    return new Promise(function (resolve, reject) {\n        chrome.fileSystem.chooseEntry(options, function (entry) {\n            if (chrome.runtime.lastError) {\n                reject(chrome.runtime.lastError);\n            } else {\n                resolve(entry);\n            }\n        });\n    });\n}\n\nfunction restoreEntry(id) {\n    return new Promise(function (resolve, reject) {\n        chrome.fileSystem.restoreEntry(id, function (entry) {\n            if (chrome.runtime.lastError) {\n                reject(chrome.runtime.lastError);\n            } else {\n                resolve(entry);\n            }\n        });\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/chrome-app/api/fileSystem.js\n **/","'use strict';\n\nconst store = chrome.storage.local;\n\nexports.get = function (key) {\n    return new Promise(function (resolve, reject) {\n        store.get(key, function (items) {\n            if (chrome.runtime.lastError) {\n                reject(chrome.runtime.lastError);\n            } else {\n                resolve(items[key]);\n            }\n        });\n    });\n};\n\nexports.set = function (key, value) {\n    return new Promise(function (resolve, reject) {\n        store.set({\n            [key]: value\n        }, function () {\n            if (chrome.runtime.lastError) {\n                reject(chrome.runtime.lastError);\n            } else {\n                resolve(true);\n            }\n        });\n    });\n};\n\nexports.remove = function (key) {\n    return new Promise(function (resolve, reject) {\n        store.remove(key, function () {\n            if (chrome.runtime.lastError) {\n                reject(chrome.runtime.lastError);\n            } else {\n                resolve(true);\n            }\n        });\n    });\n};\n\nexports.clear = function () {\n    return new Promise(function (resolve, reject) {\n        store.clear(function () {\n            if (chrome.runtime.lastError) {\n                reject(chrome.runtime.lastError);\n            } else {\n                resolve(true);\n            }\n        });\n    });\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/chrome-app/storage.js\n **/"],"sourceRoot":""}